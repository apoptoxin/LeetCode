## p11 盛水最多的容器

从左右两边向中间收缩，每次把高度较小的边向高度较大的边移动即可，遍历一次，时间复杂度为O(n)。

原理我尽量解释：面积=宽*高，初始状态的宽度为最大的，所以，高度增加才对结果有帮助，所以需要小边向大边移动，否则，高度还是小边的高度没变化，对计算结果没有影响。

## p12 整数转罗马数字

没什么好说的，就是从大到小判断吧，一位一位（或者两位，也就是六种特例情况）输出就好了。

## p13 罗马数字转整数

和p12相反，从头到尾，每次先读两位判断是否是合法罗马数。如果不是的话就读1位判断出数字。以此类推直到读完整个字符串。

## p14 查找字符串数组中的最长公共前缀 

思路比较简单，首先，以第一个字符串作为最长的公共前缀，然后顺序用后续的字符串和这个公共前缀比较，然后更新这个前缀。比较完成后就得出结果了。

## p15 三数之和

我自己的思路：先排序，O(nlogn)。然后从头开始，固定一个位置，找另两个数，每次查找都重固定位置后一个到结尾这段找两个数，查找复杂度为O(n)。然后向后移动这个固定位置，最多移动O(n)次，所以整体时间复杂度为O(n2)。

**动态增加指针指向内存大小可以用realloc函数，学到了~** ~~像我自己写的那种方式简直是傻。~~

## p16 最接近的三数之和

和第15题三数之和思路一样，只不过，和0比较变成了和target比较，而且，不需要去重了，每次计算之后更新当前最接近的值就可以。

## p17 电话号码的字母组合

递归+hashmap。hashmap仅作为加速用，我这里没写，我的写法就是纯遍历。